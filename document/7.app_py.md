앱
=====

실질적인 구동부이다. 이 파일을 exe로 변환시킬 것이다.

    import sys
    import os
    from PyQt5.QtWidgets import *
    from PyQt5 import uic
    from PyQt5.QtCore import QDate ,QThread ,pyqtSignal, QUrl, QTimer, QEvent, Qt, QEventLoop
    from PyQt5.QtGui import QMovie, QPixmap, QDesktopServices
    #아래 두개는 py파일로 직접 제작된 모듈입니다
    import speakmodule
    import getsheet
    import json
    import classify

잘 다운받자. 사실 두개가 아니고 speakmodule, getsheet, classify 3개가 직접 제작한 모듈이다.

    #파일 디렉토리 설정과정. 해당 과정을 거쳐야 디렉토리 오류가 안남
    if getattr(sys, 'frozen', False):
        BASE_DIR = sys._MEIPASS
    else:
        BASE_DIR = os.path.dirname(os.path.abspath(__file__))
    
    #UI파일 등록
    PA_form = uic.loadUiType(os.path.join(BASE_DIR, "pa.ui"))[0]
    Virtual_form = uic.loadUiType(os.path.join(BASE_DIR, "virtual.ui"))[0]
    Main_form = uic.loadUiType(os.path.join(BASE_DIR, "main.ui"))[0]
    Setting_form = uic.loadUiType(os.path.join(BASE_DIR, "setting.ui"))[0]

늘 있는 절대경로 설정이다. 그리고 UI파일을 불러온다.

    #말하는 함수를 별도의 스레드에서 구동하기위한 클래스(gif와 동시에 실행하기위함)
    class SpeakingThread(QThread):
        # 음성 재생이 시작되었음을 알리는 시그널
        speak_started = pyqtSignal()
        # 음성 재생이 완료되었음을 알리는 시그널
        speak_finished = pyqtSignal()
    
        def __init__(self, text_to_speak, parent=None):
            super().__init__(parent)
            self.text_to_speak = text_to_speak
    
        def run(self):
            # 음성 재생 시작 전 시그널 발생
            self.speak_started.emit()
            # speakmodule.speak 함수 호출 (실제 음성 재생)
            speakmodule.speak(self.text_to_speak)
            # 음성 재생 완료 후 시그널 발생
            self.speak_finished.emit()

스레드 분리를 위한 코드이다. AI가 짜줘 자세히는 모르지만 핵심적 기능들을 설명하겠다.

스레드는 운영체제의 실행단위 중 하나다. 그런데 speakmodule에서 만든 말하기 기능을 쓰면 이미 스레드가 사용중이므로 캐릭터 사진을 띄울 수 없다. 

그래서 여러 작업을 동시에 하기위해 스레드를 분리하는것이다.

주석에 이미 설명이 잘되어있어 여기까지 설명하겠다. pyqtSignal을 나중에 사용하기때문에 잘 익혀놓자.

    class SettingWindow(QWidget, Setting_form):

모든 창은 class로 정의된다. Qwidget은 이 창의 속성을 뜻하고, form은 위에서 불러온 UI파일의 경로이다. 

    def __init__(self):
            super().__init__()
            setting = json.load(open(os.path.join(BASE_DIR, 'setting.json')))
            self.setupUi(self)
            self.setStyleSheet("background-color: #ADC2A9;") # 연한 회색 (Qt Designer에서 설정한 색상과 유사하게)
            self.setAutoFillBackground(True)
            self.ratebar.setValue(int(setting['rate']*100))
            self.pitchbar.setValue(int(setting['pitch']*100)+2000)
            self.volumebar.setValue(int(setting['volume']*100)+1000)
            self.ratelabel.setText(str(self.ratebar.value()/100.0))
            self.pitchlabel.setText(f"{((self.pitchbar.value()/100)-20.0):.2f}")
            self.volumelabel.setText(f"{((self.volumebar.value()/100)-10.0):.2f}")
            self.voiceselect.setCurrentText(classify.voice(setting['model']))
            self.characterselect.setCurrentText(classify.character(setting['character']))
            self.ratebar.valueChanged.connect(self.changerate)
            self.pitchbar.valueChanged.connect(self.changepitch)
            self.volumebar.valueChanged.connect(self.changevolume)
            self.resetbutton.clicked.connect(self.reset)
            self.returnbutton.clicked.connect(self.returning)
            self.applybutton.clicked.connect(self.apply)
            image_path = os.path.join(BASE_DIR, 'images', f'{classify.character(self.characterselect.currentText())}closed.png')
            self.charactershow.setPixmap(QPixmap(image_path))
            self.charactershow.setScaledContents(True)
            self.characterselect.currentIndexChanged.connect(self.changeimage)


__init__이라는 이름에 걸맞게 모든 설정(?)들을 모두 여기에서 작성한다.

    super().__init__()
    self.setupUi(self)

이부분은 건드릴필요가 없다. 모든 곳에 공통적으로 넣어야 하는 코드이다.

    setting = json.load(open(os.path.join(BASE_DIR, 'setting.json')))

이부분은 이 창이 설정창이기 때문에 setting값을 불러오는 것이다. 실시간으로 setting.json의 값을 불러오고 수정해야하기 때문이다.

    self.setStyleSheet("background-color: #ADC2A9;") # 연한 회색 (Qt Designer에서 설정한 색상과 유사하게)
            self.setAutoFillBackground(True)

이부분은 배경색 설정이기 때문에 건드리지 않아도 된다. 

            self.ratebar.setValue(int(setting['rate']*100))
            self.pitchbar.setValue(int(setting['pitch']*100)+2000)
            self.volumebar.setValue(int(setting['volume']*100)+1000)
            self.ratelabel.setText(str(self.ratebar.value()/100.0))
            self.pitchlabel.setText(f"{((self.pitchbar.value()/100)-20.0):.2f}")
            self.volumelabel.setText(f"{((self.volumebar.value()/100)-10.0):.2f}")

이부분은 설정값을 조정하는 바의 기능이다. pyqt5에서는 정수값밖에 지원하지 않지만 구글 API에서는 소수점을 지원하므로 이를 변환하는 작업이다.

만약 rate를 1.25로 설정하고 싶다면 pyqt5에서는 125의 값을 받고 이를 코드 내부에서 1.25로 변환하여 API를 요청하는것이다.

rate, volume, pitch별로 지원하는 범위가 다르므로 이를 고려하자. 잘 모르겠다면 그냥 유지하면 된다.

적기 너무 귀찮으니 나중에 완성하겠습니다
